---
globs: "src/app/**,*.tsx"
description: "Next.js 15 App Router 및 서버 컴포넌트 활용 규칙"
---

# Next.js 15 App Router 패턴

## 서버 컴포넌트 우선 원칙

**기본 원칙**: 모든 컴포넌트는 서버 컴포넌트로 작성하고, 필요한 경우에만 클라이언트 컴포넌트로 전환합니다.

### 서버 컴포넌트 vs 클라이언트 컴포넌트

```tsx
// ✅ 서버 컴포넌트 (기본)
// app/page.tsx
export default async function HomePage() {
  // 서버에서 데이터 페칭
  const data = await fetchData()
  
  return (
    <div>
      <h1>{data.title}</h1>
      {/* 서버에서 렌더링 */}
    </div>
  )
}

// ✅ 클라이언트 컴포넌트 (필요시에만)
// components/InteractiveButton.tsx
'use client'

import { useState } from 'react'

export function InteractiveButton() {
  const [count, setCount] = useState(0)
  
  return (
    <button onClick={() => setCount(count + 1)}>
      클릭 수: {count}
    </button>
  )
}
```

## 클라이언트 컴포넌트가 필요한 경우

다음 기능을 사용할 때만 `'use client'` 지시어를 추가합니다:

### 1. React Hooks 사용

```tsx
'use client'

import { useState, useEffect } from 'react'

export function QuizProgress() {
  const [progress, setProgress] = useState(0)
  
  useEffect(() => {
    // 브라우저 API 사용
  }, [])
  
  return <div>진행률: {progress}%</div>
}
```

### 2. 브라우저 API 사용

```tsx
'use client'

export function ShareButton() {
  const handleShare = async () => {
    if (navigator.share) {
      await navigator.share({
        title: '내 결과',
        url: window.location.href
      })
    }
  }
  
  return <button onClick={handleShare}>공유하기</button>
}
```

### 3. 이벤트 핸들러

```tsx
'use client'

export function AnswerButton({ onAnswer }: { onAnswer: () => void }) {
  return <button onClick={onAnswer}>답변 제출</button>
}
```

### 4. 상태 관리 (Zustand, Context 등)

```tsx
'use client'

import { useQuizStore } from '@/store/quizStore'

export function QuizContainer() {
  const { currentQuestion, answerQuestion } = useQuizStore()
  
  return (
    <div>
      <h2>{currentQuestion?.question}</h2>
      <button onClick={() => answerQuestion(...)}>답변</button>
    </div>
  )
}
```

### 5. Framer Motion 애니메이션

```tsx
'use client'

import { motion } from 'framer-motion'

export function AnimatedCard() {
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
    >
      Content
    </motion.div>
  )
}
```

## 서버 컴포넌트 활용 패턴

### 1. 데이터 페칭

```tsx
// ✅ 서버 컴포넌트에서 직접 데이터 페칭
// app/result/[type]/page.tsx
export default async function ResultPage({ 
  params 
}: { 
  params: { type: string } 
}) {
  // 서버에서 직접 데이터 가져오기
  const profile = await getPlaystyleProfile(params.type)
  
  return (
    <div>
      <h1>{profile.title}</h1>
      <p>{profile.description}</p>
    </div>
  )
}

// ❌ 클라이언트에서 useEffect로 페칭
'use client'
export default function ResultPage() {
  const [profile, setProfile] = useState(null)
  
  useEffect(() => {
    fetch('/api/profile').then(...)
  }, [])
  
  return <div>{profile?.title}</div>
}
```

### 2. 정적 데이터 렌더링

```tsx
// ✅ 서버 컴포넌트로 정적 콘텐츠 렌더링
// app/about/page.tsx
import { PLAYSTYLE_PROFILES } from '@/data/profiles'

export default function AboutPage() {
  return (
    <div>
      <h1>MBTI 유형 소개</h1>
      {Object.values(PLAYSTYLE_PROFILES).map(profile => (
        <ProfileCard key={profile.mbtiType} profile={profile} />
      ))}
    </div>
  )
}

// ProfileCard도 서버 컴포넌트로
function ProfileCard({ profile }: { profile: IPlaystyleProfile }) {
  return (
    <div>
      <h2>{profile.title}</h2>
      <p>{profile.description}</p>
    </div>
  )
}
```

### 3. 메타데이터 생성

```tsx
// ✅ 서버 컴포넌트에서 동적 메타데이터
// app/result/[type]/page.tsx
import { Metadata } from 'next'

export async function generateMetadata({ 
  params 
}: { 
  params: { type: string } 
}): Promise<Metadata> {
  const profile = await getPlaystyleProfile(params.type)
  
  return {
    title: `${profile.title} - Playstyle Profiler`,
    description: profile.description,
    openGraph: {
      title: profile.title,
      description: profile.description,
      images: [`/og-image-${params.type}.png`]
    }
  }
}

export default async function ResultPage({ params }) {
  const profile = await getPlaystyleProfile(params.type)
  return <div>{/* 결과 표시 */}</div>
}
```

## 컴포넌트 구성 전략

### 1. 서버-클라이언트 조합 패턴

서버 컴포넌트 안에 클라이언트 컴포넌트를 중첩합니다.

```tsx
// ✅ 서버 컴포넌트 (레이아웃, 정적 콘텐츠)
// app/quiz/page.tsx
export default async function QuizPage() {
  const questions = await getQuestions()
  
  return (
    <div>
      {/* 서버에서 렌더링되는 정적 부분 */}
      <header>
        <h1>게임 플레이스타일 퀴즈</h1>
      </header>
      
      {/* 클라이언트 컴포넌트 (인터랙티브) */}
      <QuizContainer questions={questions} />
      
      {/* 서버 컴포넌트 (정적 푸터) */}
      <footer>
        <p>© 2025 Playstyle Profiler</p>
      </footer>
    </div>
  )
}
```

```tsx
// components/quiz/QuizContainer.tsx
'use client'

import { useQuizStore } from '@/store/quizStore'
import type { IQuestion } from '@/types'

export function QuizContainer({ questions }: { questions: IQuestion[] }) {
  const { currentQuestion, answerQuestion } = useQuizStore()
  
  return (
    <div>
      {/* 인터랙티브한 퀴즈 로직 */}
    </div>
  )
}
```

### 2. Props로 데이터 전달

서버 컴포넌트에서 페칭한 데이터를 클라이언트 컴포넌트에 props로 전달합니다.

```tsx
// ✅ 서버 컴포넌트에서 데이터 페칭 후 전달
// app/dashboard/page.tsx
export default async function DashboardPage() {
  const userStats = await fetchUserStats()
  const recommendations = await fetchRecommendations()
  
  return (
    <div>
      {/* 클라이언트 컴포넌트에 데이터 전달 */}
      <InteractiveDashboard 
        stats={userStats}
        recommendations={recommendations}
      />
    </div>
  )
}
```

### 3. 클라이언트 컴포넌트 최소화

클라이언트 컴포넌트는 가능한 작게 유지합니다.

```tsx
// ✅ 인터랙티브 부분만 클라이언트 컴포넌트로
// components/AnswerButton.tsx
'use client'

export function AnswerButton({ onAnswer }: { onAnswer: () => void }) {
  return <button onClick={onAnswer}>제출</button>
}

// 사용하는 부모는 서버 컴포넌트
// app/quiz/page.tsx
export default function QuizPage() {
  return (
    <div>
      <h1>질문</h1>
      <p>정적 콘텐츠...</p>
      <AnswerButton onAnswer={handleAnswer} /> {/* 이 부분만 클라이언트 */}
    </div>
  )
}
```

## App Router 파일 구조

### 페이지 구조

```
app/
├── page.tsx              # 메인 페이지 (/)
├── layout.tsx            # 루트 레이아웃
├── loading.tsx           # 로딩 UI
├── error.tsx             # 에러 UI
├── not-found.tsx         # 404 페이지
│
├── quiz/
│   ├── page.tsx          # 퀴즈 페이지 (/quiz)
│   └── layout.tsx        # 퀴즈 레이아웃
│
└── result/
    ├── page.tsx          # 결과 목록 (/result)
    └── [type]/
        └── page.tsx      # 특정 결과 (/result/INTJ)
```

### 레이아웃 활용

```tsx
// ✅ 공통 레이아웃
// app/layout.tsx
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="ko">
      <body>
        {/* 모든 페이지에 공통 적용 */}
        <Header />
        <main>{children}</main>
        <Footer />
      </body>
    </html>
  )
}

// ✅ 중첩 레이아웃
// app/quiz/layout.tsx
export default function QuizLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className="quiz-container">
      {/* 퀴즈 페이지에만 적용되는 레이아웃 */}
      <QuizProgress />
      {children}
    </div>
  )
}
```

### Loading & Streaming

```tsx
// ✅ 로딩 UI
// app/quiz/loading.tsx
export default function Loading() {
  return (
    <div className="flex items-center justify-center min-h-screen">
      <Loader2 className="animate-spin" />
      <p>퀴즈를 불러오는 중...</p>
    </div>
  )
}

// ✅ Suspense로 스트리밍
// app/result/page.tsx
import { Suspense } from 'react'

export default function ResultPage() {
  return (
    <div>
      <h1>결과</h1>
      
      <Suspense fallback={<ResultSkeleton />}>
        <ResultContent />
      </Suspense>
    </div>
  )
}
```

## 라우팅 패턴

### 1. 동적 라우트

```tsx
// app/result/[type]/page.tsx
export default async function ResultDetailPage({
  params
}: {
  params: { type: string }
}) {
  const profile = PLAYSTYLE_PROFILES[params.type as MBTIType]
  
  if (!profile) {
    notFound()
  }
  
  return <ResultDetail profile={profile} />
}

// 정적 경로 생성
export async function generateStaticParams() {
  const types = Object.keys(PLAYSTYLE_PROFILES)
  
  return types.map((type) => ({
    type: type,
  }))
}
```

### 2. 프로그래매틱 네비게이션

```tsx
'use client'

import { useRouter } from 'next/navigation'

export function QuizComplete() {
  const router = useRouter()
  const { result } = useQuizStore()
  
  const handleViewResult = () => {
    router.push(`/result/${result.mbtiType}`)
  }
  
  return <button onClick={handleViewResult}>결과 보기</button>
}
```

### 3. 링크 프리페칭

```tsx
import Link from 'next/link'

// ✅ 자동 프리페칭
<Link href="/quiz" prefetch={true}>
  퀴즈 시작하기
</Link>

// 조건부 렌더링
{isCompleted && (
  <Link href={`/result/${mbtiType}`}>
    결과 보기
  </Link>
)}
```

## 데이터 캐싱

### 1. Fetch 캐싱

```tsx
// ✅ 캐시 제어
export async function getProfile(type: string) {
  const res = await fetch(`/api/profile/${type}`, {
    cache: 'force-cache',      // 기본값: 캐시 사용
    // cache: 'no-store',       // 캐시 사용 안 함 (항상 최신 데이터)
    // next: { revalidate: 60 } // 60초마다 재검증
  })
  
  return res.json()
}
```

### 2. 정적 생성 (SSG)

```tsx
// ✅ 빌드 시 정적 생성
export default async function ProfilePage({ params }) {
  const profile = await getProfile(params.type)
  return <div>{profile.title}</div>
}

// 정적 경로 생성
export async function generateStaticParams() {
  return Object.keys(PLAYSTYLE_PROFILES).map(type => ({ type }))
}
```

## 성능 최적화

### 1. 서버 컴포넌트로 번들 크기 감소

```tsx
// ✅ 서버 컴포넌트는 클라이언트 번들에 포함되지 않음
// 큰 라이브러리도 서버에서만 사용 가능
import { marked } from 'marked' // 서버에서만 실행

export default async function MarkdownPage() {
  const content = await fetch('/content.md').then(r => r.text())
  const html = marked(content)
  
  return <div dangerouslySetInnerHTML={{ __html: html }} />
}
```

### 2. 병렬 데이터 페칭

```tsx
// ✅ 병렬로 여러 데이터 페칭
export default async function DashboardPage() {
  const [stats, profile, recommendations] = await Promise.all([
    fetchStats(),
    fetchProfile(),
    fetchRecommendations()
  ])
  
  return (
    <div>
      <Stats data={stats} />
      <Profile data={profile} />
      <Recommendations data={recommendations} />
    </div>
  )
}
```

## 주의사항

### ❌ 서버 컴포넌트에서 불가능한 것

```tsx
// ❌ 서버 컴포넌트에서 불가능
export default function ServerComponent() {
  const [state, setState] = useState(0)  // ❌ Hooks 사용 불가
  
  useEffect(() => {}, [])                // ❌ useEffect 사용 불가
  
  const handleClick = () => {}           // ⚠️ 이벤트 핸들러만으로는 작동 안함
  
  return <button onClick={handleClick}>클릭</button>
}
```

### ✅ 올바른 패턴

```tsx
// ✅ 서버 컴포넌트
export default function ServerComponent() {
  return (
    <div>
      <h1>정적 콘텐츠</h1>
      <ClientButton />  {/* 클라이언트 컴포넌트 사용 */}
    </div>
  )
}

// components/ClientButton.tsx
'use client'
export function ClientButton() {
  const [count, setCount] = useState(0)
  return <button onClick={() => setCount(c => c + 1)}>{count}</button>
}
```

## 참고 자료

- Next.js 15 공식 문서: https://nextjs.org/docs
- App Router 가이드: https://nextjs.org/docs/app
- 서버 컴포넌트: https://nextjs.org/docs/app/building-your-application/rendering/server-components
